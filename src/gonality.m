function UniformizingDifferential(omegas, x)
/*
Given a sequence omegas of differentials on a function field and a place x on the same function field,
returns a differential of omegas with valuation 0 at x.
*/
    for omega in omegas do
        if Valuation(Divisor(omega), x) eq 0 then
            return omega;
        end if;
    end for;
    error "No differential with valuation zero";
end function;

function UniformizingParameter(fs, x)
/*
Given a sequence fs of functions on a function field and a place x on the same function field,
returns an element of the function field with valuation 1 at x.

TODO: can remove fallback if X is hyperelliptic by computing a Weierstrass model uing IsHyperelliptic and working with functions on it
*/
    CF := ConstantField(FunctionField(x));
    
    for f in fs do
        ux := Evaluate(MinimalPolynomial(Evaluate(f, x), CF), f);
        if Valuation(ux, x) eq 1 then
            return ux;
        end if;
    end for;
    return UniformizingElement(x);
end function;

function DifferentialExpansionMatrices(omegas, x, d)
/*
Given a sequence omegas of differentials on a function field, a place x on the same function field,
and a precision d, returns a sequence of d matrices, the ith of which encodes the ith coefficient of
the Laurent series expansion of each differential of omegas at x.
*/
    F := FunctionField(x);
    CFx := ResidueClassField(x);
    CF := ConstantField(F);
    du := UniformizingDifferential(omegas, x);
    
    fs := [F!RationalFunction(omega/du) : omega in omegas]; // Why does RationalFunction make Evaluate much faster in certain cases?
    as := [Eltseq(Evaluate(f, x), CF) : f in fs];
    expansions := [Matrix(as)];
    
    if d gt 1 then
        u := UniformizingParameter(fs, x);
        uinv := 1/u;
        v := Lift(Generator(CFx, CF), x);
        
        for _ in [2..d] do
            for i -> f in fs do
                g := &+[c * v^(e-1) : e -> c in as[i]];
                fs[i] := F!RationalFunction((f - g)*uinv);
                as[i] := Eltseq(Evaluate(fs[i], x), CF);
            end for;
            Append(~expansions, Matrix(as));
        end for;
    end if;
    
    return expansions;
end function;

function IntegerSolutions(ns, d)
/*
Returns all nonnegative integer vectors [i1, ..., ik] such that i1*ns[1] + ... + ik*ns[k] = d
*/
    ns2 := Seqset(ns);
    parts := RestrictedPartitions(d, ns2);
    return [ [Multiplicity(M, n) : n in ns] where M := Multiset(P) : P in parts ];
end function;

function DivisorCandidatesByPartition(degree_counts, degree_partition, n)
/* The places up to degree d on FF are assumed to be stored in a list of list as generated by the following code:

places := [Places(FF, i) : i in [1..d]];

The degree_counts list stores how many places there are of each degree, i.e. `degree_counts := [#p : p in places];`

The degree_partition is a partition returned by IntegerSolutions(degree_counts, d) and tells how often we should include
a place of each degree when building the divisor.

A divisor is stored as a list of multisets, where the elements in the i-th multiset correspond to indices places[i]
For example the list of multisets: <{* 4^^2 *}, {* 10 *}, {* *}, {* *}> 
corresponds to the divisor 2*places[1][4] + places[2][10]
And the list of multisets:   <{* 7, 9 *}, {* 3 *}, {* *}, {* *}>,
corresponds to the divisor places[1][7] + places[1][9]  + places[2][3]

The integer n indicates how many places of degree 1 should be in D.
*/
    d := #degree_partition;
    assert degree_partition[1] ge n;
    if n le 1 then
        return CartesianProduct([Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [1..d]]);
    end if;
    
    S1 := {S : S in Multisets({1..degree_counts[1]}, degree_partition[1]) | #Set(S) ge n};
    return CartesianProduct([S1] cat [Multisets({1..degree_counts[i]}, degree_partition[i]) : i in [2..d]]);
end function;

function DivisorCandidates(degree_counts, n, cache, filter : First := false, MaximumTime := Infinity())
/* Loop over all divisors D of degree equal to #degree_counts and return those that satisfy filter(D) eq true.  See DivisorCandidatesByPartition how divisors are
represented.
Cache can be anything and will be passed to the filter function. It can be used to make sure that the filter function has access to
precomputed data (like expansions of differentials at the different places).

If First is true (default = false) then only return the first divisor that satisfies the filter

The integer n gives a lower bound on how many places of degree 1 should be in the divisor D. So setting n=0 causes the code 
to loop over all divisors D of degree equal to #degree_counts.
*/
    start_time := Realtime();
    d := #degree_counts;
    divisors := [];
    divisors_tried := 0;
    for degree_partition0 in IntegerSolutions([1..Max(d - n, 1)], d - n) do
        degree_partition := degree_partition0;
        degree_partition[1] := degree_partition[1] + n;
        vprint Gonality: "Testing divisors of shape", degree_partition;
        for D in DivisorCandidatesByPartition(degree_counts, degree_partition, n) do
            divisors_tried +:= 1;
            if filter(D, cache) then
                if First then return [D], divisors_tried; end if;
                Append(~divisors, D);
            end if;

            if Realtime(start_time) ge MaximumTime then
                return -1, divisors_tried;
            end if;
        end for;
    end for;
    return divisors, divisors_tried;
end function;

function PrecomputePowerseriesExpansions(FF, places, precisions : MaximumTime := Infinity())
    // The PowerseriesExpansions at all x in places
    // up to precision precisions[deg(x)]
    /*
    Returns expansions, where expansions[i][j][k] stores the (k-1)th coordinate of the expansion of
    the basis differentials of FF at degree i place places[i][j]. 
    */
    start_time := Realtime();
    expansions := <>;
    differentials := BasisOfHolomorphicDifferentials(FF);
    for i in [1..#places] do
        degree_i_expansions := [];
        for x in places[i] do
            Append(~degree_i_expansions, DifferentialExpansionMatrices(differentials, x, precisions[i]));

            if Realtime(start_time) ge MaximumTime then
                return -1;
            end if;
        end for;
        Append(~expansions, degree_i_expansions);
    end for;
    return expansions;
end function;

function DifferentialVanishingMatrix(expansions, D)
    // The matrix that describes the relations the differentials must satisfy to vanish at
    // the divisor D
    // expansions: precomputed powerseries expansions at the different places
    // D: divisor in the format described in DivisorCandidatesByPartition
    return HorizontalJoin(<expansions[i][j][k] : k in [1..n], j -> n in x, i -> x in D>);
end function;

function HasNonconstantFunction(D, powerseries_expansions)
    // Riemann Roch states h^0(D) - h^0(Omega(-D)) = deg D + 1 - g
    // so h^0(D) >= 2 if and only if h^0(Omega(-D)) + deg D + 1 - g >= 2
    // meaning h^0(Omega(-D)) >= g-deg D -1
    // The vanishing matrix is a g by deg D matrix whose kernel is h^0(Omega(-D))
    // so the condition is that the vanishing matrix should have rank < deg D
    M := DifferentialVanishingMatrix(powerseries_expansions, D);
    d := NumberOfColumns(M);
    r := Rank(M);
    return r lt d;
end function;

function HasNonconstantFunctionHess(D, places)
    divisor := &+[exponent * Divisor(places[degree][place]) : place -> exponent in multiset, degree -> multiset in D];
    return Dimension(divisor) gt 1;
end function;

declare verbose Gonality, 1;

timing_data_format := recformat<place_degree_bound, places, divisors, place_enumeration_time, expansions_time, riemann_roch_time, timeout>;

intrinsic HasFunctionOfDegreeAtMost(FF::FldFun, d::RngIntElt : Method := "Linear algebra", MaximumTime := Infinity(), TimingData := false, StopAfterFirst := true) -> BoolElt
{ Returns whether there is a function on FF with degree at most d. }
    if DimensionOfExactConstantField(FF) ne 1 then
        return HasFunctionOfDegreeAtMost(ConstantFieldExtension(FF, ExactConstantField(FF)), d div DimensionOfExactConstantField(FF) : Method := Method, MaximumTime := MaximumTime, TimingData := TimingData);
    end if;

    start_time := Realtime();
    timing_data := rec<timing_data_format | place_degree_bound := 0, places := 0, divisors := 0, place_enumeration_time := 0, expansions_time := 0, riemann_roch_time := 0, timeout := false>;

    if d gt Genus(FF) then
        if TimingData then
            return true, timing_data;
        else
            return true;
        end if;
    end if;
    
    place_start_time := Cputime();
    timing_data`place_degree_bound := 1;
    timing_data`places := #Places(FF, 1);
    timing_data`place_enumeration_time := Cputime(place_start_time);

    if d eq Genus(FF) and #Places(FF, 1) gt 0 then
        if TimingData then
            return true, timing_data;
        else
            return true;
        end if;
    end if;
    
    n := Ceiling(#Places(FF, 1) / (#ConstantField(FF) + 1));
    if n gt d then
        if TimingData then
            return false, timing_data;
        else
            return false;
        end if;
    end if;

    n1 := Min(n, d - 1);
    timing_data`place_degree_bound := d - n1;
    vprint Gonality: "Computing places of degree at most", d - n1;
    places := [Places(FF, i) : i in [1..(d - n1)]] cat [[] : i in [1..n1]];
    degree_counts := [#p : p in places];
    timing_data`places := &+degree_counts;
    timing_data`place_enumeration_time := Cputime(place_start_time);

    case Method:
        when "Linear algebra":
            vprint Gonality: "Precomputing power series expansions";
            expansion_start_time := Cputime();
            precisions := [i eq 1 select d else (d - n1) div i : i in [1..d]];
            powerseries_expansions := PrecomputePowerseriesExpansions(FF, places, precisions : MaximumTime := MaximumTime - Realtime(start_time));
            timing_data`expansions_time := Cputime(expansion_start_time);

            if powerseries_expansions cmpeq -1 then
                // Timeout
                timing_data`timeout := true;
                if TimingData then
                    return -1, timing_data;
                else
                    return -1;
                end if;
            end if;

            riemann_roch_start_time := Cputime();
            g_d_1s, timing_data`divisors := DivisorCandidates(degree_counts, n, powerseries_expansions, HasNonconstantFunction : First := StopAfterFirst, MaximumTime := MaximumTime - Realtime(start_time));
            timing_data`riemann_roch_time := Cputime(riemann_roch_start_time);
        when "Hess":
            riemann_roch_start_time := Cputime();
            g_d_1s, timing_data`divisors := DivisorCandidates(degree_counts, n, places, HasNonconstantFunctionHess : First := StopAfterFirst, MaximumTime := MaximumTime - Realtime(start_time));
            timing_data`riemann_roch_time := Cputime(riemann_roch_start_time);
        else:
            error "Method must be \"Linear algebra\" or \"Hess\"";
    end case;

    if g_d_1s cmpeq -1 then
        // Timeout
        timing_data`timeout := true;
        if TimingData then
            return -1, timing_data;
        else
            return -1;
        end if;
    end if;

    if TimingData then
        return #g_d_1s ge 1, timing_data;
    else
        return #g_d_1s ge 1;
    end if;
end intrinsic;

intrinsic Gonality(FF::FldFun : Bound := -1, Method := "Linear algebra", MaximumTime := Infinity()) -> RngIntElt
{ Computes the gonality of the function field FF. The Bound parameter is a parameter specifying
up to which degree to look for functions.

If the optional parameter Bound is not provided then it will return the gonality. 
If the parameter Bound is a positive integer then the return value d will always be
at most Bound + 1; And the meaning of d is as follows:
If d <= Bound then d equals the gonality of FF;
If d = Bound + 1 then d is a lowerbound for the gonality of FF. }
    if DimensionOfExactConstantField(FF) ne 1 then
        return DimensionOfExactConstantField(FF) * Gonality(ConstantFieldExtension(FF, ExactConstantField(FF)));
    end if;

    if Genus(FF) eq 0 then
        return 1;
    end if;
    if Genus(FF) le 2 then
        return 2;
    end if;

    start_time := Realtime();
    d := 1;
    while d ne Bound+1 do
        vprint Gonality: "Trying degree", d;
        has_function := HasFunctionOfDegreeAtMost(FF, d : Method := Method, MaximumTime := MaximumTime - Realtime(start_time));
        if has_function cmpeq -1 then
            // Timeout
            return -1;
        elif has_function then
            break;
        end if;
        d +:= 1;
    end while;
    return d;
end intrinsic;

intrinsic HasFunctionOfDegreeAtMost(C::Crv[FldFin], d::RngIntElt : Method := "Linear algebra", MaximumTime := Infinity(), TimingData := false, StopAfterFirst := true) -> BoolElt
{ Returns whether there is a function on C with degree at most d. }
    FF := AlgorithmicFunctionField(FunctionField(C));
    return HasFunctionOfDegreeAtMost(FF, d : Method := Method, MaximumTime := MaximumTime, TimingData := TimingData, StopAfterFirst := StopAfterFirst);
end intrinsic;

intrinsic Gonality(C::Crv[FldFin] : Bound := -1, Method := "Linear algebra", MaximumTime := Infinity()) -> RngIntElt
{ Computes the gonality of the curve C. The Bound parameter is a parameter specifying
up to which degree to look for functions.

If the optional parameter Bound is not provided then it will return the gonality. 
If the parameter Bound is a positive integer then the return value d will always be
at most Bound + 1; And the meaning of d is as follows:
If d <= Bound then d equals the gonality of FF;
If d = Bound + 1 then d is a lowerbound for the gonality of FF. }
    FF := AlgorithmicFunctionField(FunctionField(C));
    return Gonality(FF : Bound := Bound, Method := Method, MaximumTime := MaximumTime);
end intrinsic;

/* Example usage

//IntegerSolutions
ns := [1, 2, 3, 4];
d := 4;
print IntegerSolutions(ns, d);

//DivisorCandidatesByPartition
degree_counts := [ 4, 12, 8, 0 ];
degree_partition := [ 2, 1, 0, 0 ];
divs := DivisorCandidatesByPartition(degree_counts, degree_partition);
print divs;

//DivisorCandidates
degree_counts := [ 2, 2, 2, 0 ];
divs := DivisorCandidates(degree_counts, [], func< D, cache | true>);
print divs;
print DivisorCandidates(degree_counts, [], func< D, cache | true> : First := true);

//DifferentialExpansionMatrices
d := 4;
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
FF := AlgorithmicFunctionField(FunctionField(C));
x := Places(FF,2)[2];
differentials := BasisOfHolomorphicDifferentials(FF);

f := DifferentialExpansionMatrices(differentials, x, d);
print f;

//PrecomputePowerseriesExpansions
places := [Places(FF, i) : i in [1..d]];
powerseries_expansions := PrecomputePowerseriesExpansions(FF, places, d);
print powerseries_expansions;

//DifferentialVanishingMatrix
DifferentialVanishingMatrix(powerseries_expansions, D);

//HasFunctionOfDegreeAtMost
P<x,y,z> := ProjectiveSpace(GF(3), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
// this curve has gonality 3 over F_3
HasFunctionOfDegreeAtMost(C, 2), HasFunctionOfDegreeAtMost(C, 3);

P<x,y,z> := ProjectiveSpace(GF(5), 2);
// https://beta.lmfdb.org/ModularCurve/Q/8.96.3.e.1/
f := 4*x^4 - y^4 - z^4;
C := Curve(P,f);
// but gonality 4 over F_5
HasFunctionOfDegreeAtMost(C, 3), HasFunctionOfDegreeAtMost(C, 4);

//Gonality
Gonality(C);
SetVerbose("Gonality", 1);
Gonality(C : Bound:=3);

*/
